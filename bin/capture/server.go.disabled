// Copyright (c) 2019 David Vogel
//
// This software is released under the MIT License.
// https://opensource.org/licenses/MIT

package main

import (
	"bufio"
	"log"
	"net"
	"strconv"
	"strings"
)

func startServer() {
	log.Printf("Launching server...\n")

	// listen on all interfaces
	ln, err := net.Listen("tcp", ":46789")
	if err != nil {
		log.Fatalf("Couldn't open TCP server at port 46789: %v", err)
	}

	// accept connections
	for {
		conn, err := ln.Accept()
		if err != nil {
			log.Fatalf("Couldn't accept TCP connection: %v", err)
		}

		// Handle incoming data
		go func(conn net.Conn) {
			defer conn.Close()
			var x, y int

			for {
				message, err := bufio.NewReader(conn).ReadString('\n')
				if err != nil {
					log.Printf("Couldn't read from connection: %v", err)
					return
				}

				// Check for end condition
				if message == "\n" {
					break
				}

				colonPos := strings.IndexByte(message, ':') // Expect UTF-8
				if colonPos < 0 {
					log.Printf("Missing colon in message: %v", message)
					return
				}
				key, value := message[:colonPos], message[colonPos+1:]
				log.Printf("Bla %v blub %v", key, value)
				switch key { // Expect UTF-8
				case "x":
					if res, err := strconv.ParseInt(value, 10, 0); err == nil {
						x = int(res)
					} else {
						log.Printf("Can't parse string %v to integer: %v", value, err)
						return
					}

				case "y":
					if res, err := strconv.ParseInt(value, 10, 0); err == nil {
						y = int(res)
					} else {
						log.Printf("Can't parse string %v to integer: %v", value, err)
						return
					}
				}
			}

			conn.Write([]byte("\n"))

			log.Printf("capture bla at %v, %v", x, y)

		}(conn)
	}
}
